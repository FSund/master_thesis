\chapter{AwesomeChapterName}

\begin{itemize}
    \item canonical = constant $N$, $V$ and $T$
    \item microcanonical = constant $N$, $V$ and $E$
\end{itemize}


\section{Ensemble/thermostats}
We have now developed a molecular dynamics program that simulates simple systems \hl{like liquid/gas Argon}, with constant number of particles $N$, constant volume $V$ and constant energy $E$ \hl{$V$ and $E$ depend on integrator?}, which means that the system can't exchange particles or energy with the environment. This forms a statistical ensemble called the microcanonical ensemble or the $NVE$-ensemble, \hl{which has some implications for what we can measure?}. Other ensembles that might be of interest \hl{is/are?} the canonical ensemble (constant $N$, $V$ and temperature $T$) and the grand canonical ensemble (constant chemical potential $\mu$, $V$ and $T$) \hl{and $NPT$? see Thijssen p. 209(222)}.

% \hl{To study the canonical ensemble we can use a thermostat, which is a method for controlling the temperature of the system.} \todo{transition to parts below}

The most often studied ensemble other than the microcanonical is the canonical, with constant temperature instead of energy. To study this we need a way of controlling the temperature of the system, which is usually done by using a \emph{thermostat}. A thermostat simulates the system being in contact with a heat bath with temperature $T_\text{bath}$. \todo{small discussion of how heat bath really works? see thijssen p. 203(216)} We measure the temperature via the kinetic energy of the system, so we know we have to \hl{modify} the velocities of the system to control the temperature. 

\orangebox{
    \begin{itemize}
        \item Thermostats == change ensemble
        \item Measure pressure, Frenkel eq. (3.4.1) p. 52.
        \item Measure temperature, Frenkel eq. (4.1.1) and (4.1.2) p. 64
    \end{itemize}
}

\subsection{Berendsen thermostat}
Perhaps the simplest example of a thermostat is the Berendsen thermostat\cite{berendsen1984molecular}, which \hl{simply} rescales all velocities by muliplying them with a factor $\gamma$
\begin{align*}
    \gamma = \sqrt{1 + \frac{\Delta t}{\tau}\left(\frac{T_\text{bath}}{T} - 1\right)},
\end{align*}
where $\Delta t$ is the timestep used in the simulations, $\tau$ controls the \hl{strength} of the thermostat (setting $\tau = \Delta t$ makes the temperature \hl{exactly constant equal to $T_\text{bath}$}), $T$ is the temperature of the system and $T_\text{bath}$ is the temperature of the \hl{simulated} heat bath. The velocities should be multiplied by this factor every timestep \hl{after calculating the new velocities}. An example of how to apply the Berendsen thermostat can be seen in \cref{list:applyBerendsenThermostat}.
%
\begin{listing}[!htb]%
\begin{cppcode*}{gobble=4}
    void applyBerendsenThermostat(System &system, double T, double Tbath, 
        double dt, double tau)
    void applyBerendsenThermostat(vector<Atom*> &atoms, double T, double Tbath, 
        double dt, double tau)
    {
        double gamma = sqrt(1 + dt/tau(Tbath/T - 1));
        for (Atom *atom : system.atoms())
        for (Atom *atom : atoms)
        {
            atom->velocity() *= gamma;
        }
    }
\end{cppcode*}
\caption{%
    \texttt{applyBerendsenThermostat}. \hl{decide on System or vector<Atom*> as input}%
    \label{list:applyBerendsenThermostat}%
}%
\end{listing}%

The Berendsen thermostat is very good at controlling and changing the temperature of a system, but it doesn't sample the canonical ensemble especially good. This is because we change the velocity of \emph{all} atoms at every timestep, which isn't \hl{physically realistic}. This means that we shouldn't use this thermostat when trying to sample the canonical ensemble, but we often use it to heat up or cool down a system, to reach a wanted temperature.

Many thermostats similar to the Berendsen thermostat exist\hl{examples?}, but they all suffer from the fact that they scale the velocity of all particles, giving unphysical behaviour.

\subsection{Andersen thermostat}
A more \hl{physically realistic} thermostat is the Andersen thermostat\hl{citation?}, which simulates \hl{(hard)} collisions between atoms in the system, and atoms in the heat bath. This thermostat uses the following procedure
%
\begin{itemize}
    \item For each atom generate a uniform random number $u$ in the interval $[0,1]$.
    \item If this random number is less than
        \begin{align*}
            u < \frac{\Delta t}{\tau},
        \end{align*}
        we assign the atom a new, normally distributed velocity with standard deviation
        \begin{align*}
            \sigma_v = \sqrt{\frac{k_B T_\text{bath}}{m}}.
        \end{align*}
\end{itemize}
%
In this thermostat $\tau$ can be seen as a collision time, \hl{and $\tau$ should have about the same value as in the Berendsen thermostat}\todo{we give no number for $\tau$ in Berendsen..}.

The Andersen thermostat samples the canonical ensemble well\hl{cite}, but disturbs the dynamics of e.g. lattice vibrations. We should avoid using this thermostat when measuring properties directly connected to the movement of each particle, since we so abruptly change the velocity and trajectory of the particles \hl{(e.g. diffusion)}.

\subsection{Nos\'e-Hoover thermostat}
The Nos\'e-Hoover thermostat is the base for a set of \hl{highly advanced} thermostats called Nos\'e-Hoover chains, that sample the canonical ensemble very well, and give very accurate dynamics. \todo{citations} This thermostat is in widespread use because of it's \hl{excellent properties}, although it is a lot harder to implement than the Berendsen and Andersen thermostat.

% To show how the thermostat works we need to formulate statistical mechanics in the language of quantum mechanics. In classical mechanics the momentum $\vec p$ of a particle is defined in terms of its velocity $\vec v$ by
% \begin{align*}
%     \vec p = m\vec v,
% \end{align*}
% where $m$ is the mass of the particle. The kinetic energy is given by
% \begin{align*}
%     K = \sum_{i=1}^N \frac{\vec p_i^2}{2m_i}.
% \end{align*}
% The Hamiltonian of the system is defined to be the sum of the potential and kinetic energy, is then given by
% \begin{align*}
%     \Ham (\vec p, \vec r) = K(\vec p) + U(\vec r) = \sum_{i=1}^N \frac{\vec p_i^2}{2m_i} + U(\vec r_i, \dots, \vec r_N),
% \end{align*}
% where $U(\vec r)$ is the potential energy of the system.

% What the Nosé-Hoover thermostat does is to introduce a heatbath in the Hamiltonian, by using an extra degree of freedom $s$. The total Hamiltonian we get is then \hl{source:} \url{http://en.wikipedia.org/wiki/Nos%C3%A9%E2%80%93Hoover_thermostat}
% \begin{align*}
%     \Ham (\tilde{\vec p}, \tilde{\vec r}, \vec p_s, s) = \sum_{i=1}^N \frac{\tilde{\vec p}_i^2}{2m_is^2} + U(\tilde{\vec r}) + \frac{p_s^2}{2Q} + 3Nk_BT \ln(s),
% \end{align*}
% where $Q$ is a parameter \hl{what does it do?} (effective mass associated with $s$ -- Frenkel), $T$ is \hl{??? wanted $T$?}, $p_s$ is \hl{???}. The coordinates in this ``extended'' system, momentum $\tilde{\vec p}_i$, position $\tilde{\vec r}_i$, and time $t$ are virtual, and can be related to the real coordinates via
% \begin{align*}
%     &\vec r_i = \vec r,&  &\vec p_i = \frac{\tilde{\vec p}_i}{s},&  &\text{and}&  &t = \int^{\tilde t} \frac{\dif \tau}{s}&
% \end{align*}

To show how the thermostat works we need to use the Lagrangian and Hamiltonian formulation of classical mechanics\todo{see where for more info?}. 
% In classical mechanics the momentum $\vec p_i$ of a particle is defined in terms of its velocity $\dot{\vec r}_i$ by
% \begin{align*}
%     \vec p_i = m_i\dot{\vec r}_i,
% \end{align*}
% where $m_i$ is the mass of the particle. The kinetic energy $K$ of the system is given by
% \begin{align*}
%     K = \sum_{i=1}^N \frac{\vec p_i^2}{2m_i}.
% \end{align*}
The Lagrangian $\Lag$ of a classical $N$-body system is defined as the kinetic energy minus the potential energy $U$
\begin{align*}
    \Lag = K - U% = \sum_{i=1}^N \frac{\vec p_i^2}{2m_i} - U(\vec r),
\end{align*}
and what is called the \emph{generalized} momentum $\vec p_i$ of a \emph{generalized} coordinate $\vec q_i$ defined as
\begin{align}
    \vec p_i = \frac{\partial \mathcal{L}}{\partial \dot{\vec q}_i},
    \label{eq:lag_momentum}
\end{align}
\hl{where we denote the time derivative by a dot.} These generalized coordinates and momenta are not bound to any one coordinate system, and may be any quantitative attribute of the system.

What the Nosé-Hoover thermostat does is to introduce an additional coordinate $s$ to the Lagrangian, creating a \hl{(virtual,)} extended system, with the following Lagrangian:
\begin{align}
    \mathcal{L}_\text{Nos\'e} = \sum_{i=1}^N \frac{m_i}{2}s^2 \dot{\vec r}_i^2 - U(\vec r) + \frac{Q}{2}\dot s^2 - 3Nk_BT \ln s,
    \label{eq:nose_lag}
\end{align}
where $Q$ is an effective ``mass'' associated with $s$, and $\vec r_i$ is the \emph{generalized} coordinate from earlier, \hl{interpreted as a virtual position of an atom using cartesian coordinates}. The momenta of this expanded system follow from \cref{eq:nose_lag,eq:lag_momentum} as
\begin{align*}
    &\vec p_i = \frac{\partial \mathcal{L}}{\partial \dot{\vec r}_i} = m_i s^2 \dot{\vec r}_i \\
    &p_s = \frac{\partial \mathcal{L}}{\partial \dot s} = Q\dot s.
\end{align*}
This gives the following Hamiltonian for the extended system
\begin{align}
    \Ham_\text{Nos\'e} = \sum_{i=1}^N \frac{\vec p_i^2}{2m_is^2} + U(\vec r) + \frac{p_s^2}{2Q} + 3Nk_BT \ln s,
    \label{eq:nose_hamiltonian}
\end{align}
It can be shown that we can relate the generalized coordinates to real variables (real variables indicated by a prime) as follows
\begin{align}
    \vec r' &= \vec r \nonumber\\
    \vec p' &= \vec p/s \nonumber\\
    s' &= s \nonumber\\
    \Delta t' &= \Delta t/s. \label{eq:nose_time_scale}
\end{align}
From \cref{eq:nose_time_scale} we see that $s$ can be interpreted as a scaling factor of the time step. \hl{Something about this scaling? real and virtual measuring times $\tau'$ and $\tau$}
% Further
% \begin{align*}
%     \tau' = \int_0^\tau \dif \frac{1}{s(t)}
% \end{align*}

From the Hamiltonian \cref{eq:nose_hamiltonian} we can derive the equations of motion for the virtual variables $\vec r$, $\vec p$, and $t$, and the real variables $\vec r'$, $\vec p'$, and $t'$ \hl{cite}
\begin{align*}
    \dod{\vec r_i'}{t'}     &= s\dod{\vec r_i}{t} = \frac{\vec p_i}{m_is} = \frac{\vec p_i'}{m_i} \\
    \dod{\vec p_i'}{t'}     &= s\dod{\vec (p_i/s)}{t} = \dod{\vec p_i}{t} - \frac{1}{s}\vec p_i\dod{s}{t} = -\frac{\partial U(\vec r')}{\partial \vec r_i'} - \frac{s'p_s'}{Q}\vec p_i' \\
    \frac{1}{s}\dod{s'}{t'} &= \frac{s}{s}\dod{s}{t} = \frac{s'p_s'}{Q} \\
    \dod{(s'p_s'/Q)}{t'}    &= \frac{s}{Q}\dod{p_s}{t} = \left( \sum_{i=1}^N \frac{p_i'^2}{m_i} - 3Nk_BT\right) / Q.
\end{align*}
\todo{remove this complicated version? we haven't derived it anyway...}
These equations can further be simplified\hl{cite Hoover [132, 133]?, Frenkel, p. 152/172}. We introduce a thermodynamic friction coefficient $\xi = s'p_s'/Q$ and drop the primes, and we get the following equations of motion
\begin{align}
    \xi             &= \frac{sp_s}{Q} \label{eq:nose_xi}\\
    \dot{\vec r}_i  &= \frac{\vec p_i}{m} \label{eq:nose_position}\\
    \dot{\vec p}_i  &= -\frac{U(\vec r)}{\partial r_i} - \xi \vec p_i \label{eq:nose_momentum}\\
    \dot\xi         &= \left( \sum_{i=1}^N \frac{p_i^2}{m_i} - 3Nk_BT \right) / Q \label{eq:nose_dotxi}%\\
%     \frac{\dot s}{s} &= \dod{\ln s}{t} = \xi
\end{align}
% Note that the last equation is redundant, since eq. 1-4 form a closed set

A problem with the Nosé-Hoover thermostat is now apparent. Since the velocity appears on both sides of \cref{eq:nose_momentum}, we can't implement it directly in the velocity Verlet integrator. To see this we consider a standard microcanonical simulation \hl{(constant $N$, $V$, and $E$}. There the velocity Verlet algorithm is of the form
(from \cref{eq:velocity_verlet_position,eq:velocity_verlet_velocity})
\begin{align*}
    \rvec(t + \Delta t) &= \rvec(t) + \vvec(t)\Delta t + \avec(t)\frac{\Delta t^2}{2}\\
    \vvec(t + \Delta t) &= \vvec(t) + \big[\avec(t) + \avec(t + \Delta t)\big] \frac{\Delta t}{2}.
\end{align*}
Using the Nosé-Hoover equations of motion in \cref{eq:nose_xi,eq:nose_position,eq:nose_momentum,eq:nose_dotxi} we get
\begin{align*}
    \rvec(t + \Delta t) &= \rvec(t) + \vvec(t)\Delta t + \left[ \frac{\vec F(t)}{m} - \xi(t)\vec v(t) \right] \frac{\Delta t^2}{2}\\
    \vvec(t + \Delta t) 
        &= \vvec(t) + \Bigg[ 
            \left(\frac{\vec F(t+\Delta t)}{m} - \xi(t+\Delta t)\vec v(t+\Delta t)\right) \\
            &\phantom{= \vvec(t) + \Big[} + \left(\frac{\vec F(t)}{m} - \xi(t)\vec v(t)\right)
        \Bigg] 
        \frac{\Delta t}{2}.
\end{align*}
We see that calculating $\vec r(t+\Delta t)$ goes well, but to calculate $\vec v(t+\Delta t)$ we see that we need to know $\vec v(t+\Delta t)$ itself \hl{($\vec v(t+\Delta t)$ appears on both sides)}. For this reason the Nosé-Hoover thermostat is usually implemented using a \hl{predictor-corrector scheme, or solved iteratively(ref [138] Frenkel, p. 535/555)}. This has the disadvantage that the solution is no longer time reversible. Martyna \emph{et al.} \hl{cite. [85] Frenkel} has developed a set of explicit reversible integrators using the \hl{Louiville approach} for this type of extended systems.\todo{this paragraph is copied from Frenkel p. 535/555..!}

\subsection{Nos\'e-Hoover chains}



% where $Q$ is a parameter \hl{what does it do?} (effective mass associated with $s$ -- Frenkel), $T$ is \hl{??? wanted $T$?}, $p_s$ is \hl{???}. The coordinates in this ``extended'' system, momentum $\tilde{\vec p}_i$, position $\tilde{\vec r}_i$, and time $t$ are virtual, and can be related to the real coordinates via
% \begin{align*}
%     &\vec r_i = \vec r,&  &\vec p_i = \frac{\tilde{\vec p}_i}{s},&  &\text{and}&  &t = \int^{\tilde t} \frac{\dif \tau}{s}&
% \end{align*}



\orangebox{
    \begin{itemize}
        \item Nosé-Hoover and Nosé-Hoover chains
    \end{itemize}
}



\section{Observables? Measurements?}
% To measure an observable quantity in a simulation we must be able to express it as a function of the positions, velocities and forces on the particles in the system. 
% 
% According to the equipartition principle, the average total kinetic energy $\langle E_k \rangle$ is
% \begin{align*}
%     \left\langle E_k \right\rangle = \left\langle \frac{1}{2}mv^2 \right\rangle = \frac{3}{2}Nk_B T,
% \end{align*}
% from which we can derive the temperature of the system. Here $m$ is the mass of a particle, $v$ is the speed of a particle, and $T$ is the corresponding temperature of the system.
% 
% An often used method for measuring the pressure $P$ is derived from the virial equation for the pressure, which gives
% \begin{align*}
%     P = \rho k_B T + \frac{1}{3V}\sum_i \sum_{j>i} \bvec F(\rvec_{ij}) \cdot \rvec_{ij},
% \end{align*}
% where $V$ is the volume, $\rho$ is the atom density, $\bvec F(\bvec r)$ is the force between two atoms separated by $\bvec r$, and $\rvec_{ij} = \rvec_j - \rvec_i$ is the vector between atom $i$ and atom $j$. \hl{1) this equation depends on the ensemble, and is only valid for micro-canonical ensemble -- project 1 FYS4460} \hl{2) this expression is derived for a system at constant $N$, $V$, and $T$, see Frenkel p. 84(104) sec. 4.4}.
%
%
%
\begin{listing}[!htb]%
\begin{cppcode*}{gobble=4}
    void sample(System &system)
    {
    }
\end{cppcode*}
\caption{%
    \hl{FINISH THIS LISTING}. Implementation of the function \texttt{sample} from \cref{list:simple_md_program}.%
    \label{list:sampling}%
}%
\end{listing}%
\todo{finish this listing}


\subsection{Temperature}
\todo[inline]{derivation of temperature? See Anderhaf}
According to the equipartition principle the average total kinetic energy \hl{per atom}, for a system consisting of $N$ particles with three degrees of freedom each, can be related to the temperature of the system via
\begin{align*}
    \Braket{E_k} = \frac{3}{2}Nk_\text{B}T,
\end{align*}
where $T$ is the temperature of the system. We calculate the average kinetic energy using
\begin{align*}
    \Braket{E_k} = \frac{1}{2N}\sum_{i=1}^N m_i v_i^2,
\end{align*}
where $m_i$ and $v_i = |\vec v_i|$ is respectively the mass and speed of atom $i$. 

See \cref{list:temperatureSample} for an example of how to calculate the temperature in a molecular dynamics simulation.
%
\begin{listing}[!htb]%
\begin{cppcode*}{gobble=4}
    double temperatureSample(System &system)
    {
        double kineticEnergy = 0.0;
        for (Atom *atom : system.atoms())
        {
            kineticEnergy += atom->velocity().lenghtSquared();
        }

        kineticEnergy *= 0.5;
        double temperature = 2.0*kineticEnergy/(3.0*system.nAtoms()
                                                *boltzmannConstant);  // SI units
        return temperature;
    }
\end{cppcode*}
\caption{%
    An example of how to calculate the temperature in a molecular dynamics simulation. Example implementation of \texttt{temperatureSample} from \cref{list:sampling}.%
    \label{list:temperatureSample}%
}%
\end{listing}%

\todo[inline]{Something about temperature in system with flow? (not that relevant for me though...)}

\subsection{Pressure\label{subsec:pressure}}
\todo[inline]{derivation of pressure? See Anderhaf}
To measure the pressure when using potentials with pairwise additive interactions, like the case is for our example program with the Lennard-Jones potential, we can use a method derived from the virial equation for the pressure\cite[Section~4.4]{frenkel2001understanding}. In a volume $V$ with particle density $\rho = N/V$, the average pressure is
% For pairwise additive interactions we can write\cite[Section~4.4]{frenkel2001understanding}
\begin{align}
    P = pk_\text{B}T + \frac{1}{dV} \Braket{\sum_{i<j} \bvec F (\bvec r_{ij}) \cdot \bvec r_{ij}},
    \label{eq:measure_pressure}
\end{align}
where $\vec F(\rvec_{ij})$ is the force between particle $i$ and $j$, and $\rvec_{ij}$ is the distance between the particles. \hl{Note that this expression for the pressure has been derived for a system at constant $N$, $V$ and $T$, whereas our simulations are performed at a constant $N$, $V$, and $E$}

We see that we need the force from each atom $j$ on atom $i$, $\vec F(\rvec_{ij})$ to calculate the pressure, so for efficiency we should calculate the contribution to the pressure, $\vec F(\rvecij)\cdot\rvecij$, while doing the force calculations. The contribution to the pressure should then be stored so we can calculate the average in \cref{eq:measure_pressure} later.

An example of how to calculate the pressure in a molecular dynamics simulation can be seen in \cref{list:pressureSample}.
%
\begin{listing}[!htb]%
\begin{cppcode*}{gobble=4}
    double pressureSample(System &system, double temperature)
    {
        double pressure;
        for (Atom *atom : system.atoms())
        {
            pressure += atom->pressure();
        }
        pressure /= (3.0*system.volume());
        double density = system.nAtoms()/system.volume(); // Assume homogeneous
        pressure += density*boltzmannConstant*temperature; // SI units
        return pressure;
    }
\end{cppcode*}
\caption{%
    An example of how to calculate the pressure in a molecular dynamics simulation. Example implementation of \texttt{pressureSample} from \cref{list:sampling}. Note that this function needs the temperature of the system as input, and assumes that the system is homogeneous, so we can estimate the density using $\rho = N/V$. We assume that the contribution to the pressure from each atom $\sum_{i<j}\vec F(\rvec_{ij})\cdot\rvec_{ij}$ (stored as \texttt{atom->pressure()}) has been calculated previously. This is usually calculated while calculating the forces between the atoms, since we need $\vec F(\rvec_{ij})$. See \cref{subsec:pressure} for more information.%
    \label{list:pressureSample}%
}%
\end{listing}%

\subsection{Diffusion}
\todo[inline]{derivation of diffusion? See \cite[Section~4.4.1]{frenkel2001understanding}}
We can measure the diffusion constant $D$ by measuring the square displacement $r_i^2(t)$ of each atom as a function of time, and averaging over all atoms. We measure the mean square displacement as
\begin{align*}
    \Braket{r^2(t)} = \frac{1}{N} \sum_{i=1}^N \left( \rvec_i(t) - \rvec_i(t=0) \right)^2,
\end{align*}
where $\rvec_i(t=0)$ is the initial position of atom $i$. From theoretical considerations of the diffusion process we can relate the diffusion constant to the mean square displacement through\cite[Section~4.4.1]{frenkel2001understanding}
\begin{align*}
    &\Braket{r^2(t)} = 2dDt &\text{when }t\rightarrow \infty,
\end{align*}
where $d$ is the \hl{spatial} dimensionality. This means that we can find the diffusion constant in a molecular dynamics simulation by measuring the mean square displacement for many timesteps, and plotting $\Braket{r^2(t)}/(2dt)$ as a function of time. The diffusion constant will then be the value this expression approaches when simulating for enough timesteps.

An example of how to measure the mean square displacement in a molecular dynamics simulation can be seen in \cref{list:diffusionSample}.
% Fick's law relates flux $\bvec j$ of diffusing species to the concentration gradient $\bvec \nabla c$ of the species
% \begin{align*}
%     \bvec j = -D\bvec \nabla c,
% \end{align*}
% where $D$ is the proportionality constant called the diffusion \hl{coefficient/constant}.
% 
% Conservation of \hl{species/atoms?}
% \begin{align*}
%     \dpd{c(r,t)}{t} + \div \cdot \vec j(r,t) = 0,
% \end{align*}
% which gives
% \begin{align}
%     \dpd{c(r,t)}{t} - D\nabla^2 c(r,t) = 0.
%     \label{eq:diffusion_diff}
% \end{align}
% % We can solve this equation with the boundary condition
% % \begin{align*}
% %     c(r,0) = \delta (r),
% % \end{align*}
% % where $\delta(r)$ is the Dirac delta function, which gives
% % \begin{align*}
% %     c(r,t) = \frac{1}{(4\pi Dt)^{d/2}} \exp\left(-\frac{r^2}{4Dt}\right).
% % \end{align*}
% By multiplying \cref{eq:diffusion_diff} by $r^2$ and integrating over all space we get
% \begin{align*}
%     \dpd{}{t}\int \drvec~ r^2 c(r,t) = D\int \drvec~ r^2 \nabla^2 c(r,t).
% \end{align*}
% We recognize the integral on the left-hand side as the the mean square displacement %\hl{time dependence of the second moment of $c(r,t)$???}
% \todo{what???}
% \begin{align*}
%     \int \drvec~ c(r,t) r^2 \equiv \Braket{r^2(t)},
% \end{align*}
% where we have imposed
% \begin{align*}
%     \int \drvec~ c(r,t) = 1.
% \end{align*}
% Applying partial integration to the right-hand side we obtain
% \begin{align*}
%     \dpd{\Braket{r^2(t)}}{t} 
%     &= D\int \drvec~ r^2 \nabla^2 c(r,t) \\
%     &= D\int \drvec~ \div \cdot \left(r^2\nabla c(r,t)\right) - D\int\drvec~ \div r^2 \cdot \nabla c(r,t) \\
%     &= D\int \dif \vec S~ \left(r^2\div c(r,t)\right) - 2D\int\drvec~ \rvec \cdot\div c(r,t) \\
%     &= 0 - 2D\int\drvec~ (\div \cdot \rvec c(r,t)) + 2D\int\drvec~ (\div \cdot \rvec) c(r,t) \\
%     &= 0 + 2dD\int \drvec~ c(r,t) \\
%     &= 2dD
% \end{align*}
% 
% 
% \begin{align*}
%     \dpd{\Braket{r^2(t)}}{t} = 6D
% \end{align*}
% $\Rightarrow$ Plot mean square distance as function of time
% \begin{align*}
%     \Braket{\delta r(t)^2} = \frac{1}{N} \sum_{i=1}^N \delta \rvec_i(t)^2
% \end{align*}
% and find $6D$ as slope of plot \hl{(after a while?)}
%
\begin{listing}[!htb]%
\begin{cppcode*}{gobble=4}
    double diffusionSample(System &system)
    {
        double rSquared = 0.0;
        for (Atom *atom : system.atoms())
        {
            drVec = atom->positiom() - atom->initialPosition() 
                    + atom->getBoundaryCrossings()*system.size();
            rSquared += drVec.lengthSquared();
        }
        rSquared /= system.nAtoms();
        return rSquared;
    }
\end{cppcode*}
\caption{%
    An example of how to calculate the mean square displacement in a molecular dynamics simulation. Example implementation of \texttt{diffusionSample} from \cref{list:sampling}. We store the inital positions of the atoms as \texttt{atom->initialPosition()}, and when using periodic boundary conditions we count the number of times we have to translate the atom one system-size in each direction, so while the position of the atom will always be inside the system, the \hl{\emph{real}} position of the atom can be calculated by adding \texttt{atom->getBoundaryCrossings()*system.size()} to $\rvec$.%
    \label{list:diffusionSample}%
}%
\end{listing}%
