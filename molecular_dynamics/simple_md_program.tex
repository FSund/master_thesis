\chapter{A simple molecular dynamics model\label{chap:simple_md_program}}
Intro

From old stat mec chapter:
In molecular dynamics we study systems of many interacting atoms and molecules by assuming that they behave classically, and solve Newton's equations of motion using an appropriate integration scheme to evolve the system in time. By assuming that the atoms behave classically we mean that we model the atoms as point particles, and characterize them using their position, $\bvec r$, velocity, $\bvec v$ and the force acting on them, $\bvec f$. The interactions between the atoms, that stem from the quantum mechanical \hl{something}, are described using potentials. It is into these potentials we bake the physical insight of the systems we want to simulate, which we often do by finding potentials using studies and simulations of the underlying quantum mechanical nature of the interactions between the atoms in the system.

\section{The main program}
% Deducing how a molecular dynamics program does its simulations isn't always easy from looking at source code, but most programs will follow a flow similar to the following:
%
Most molecular dynamics programs will follow an flow similar to the following:
%
\begin{itemize}[midsep]
    \renewcommand{\labelitemii}{$\bullet$} % Set list depth 2 bullet thing equal to first
    \item Initialize the system. Set up the initial positions and velocities for all atoms, either by generating them or loading a saved state from a previous simulation.\todo{remove drift!}
    \item For each timestep
    \begin{itemize}[midsep]
        \item Calculate the forces between the atoms.
        \item Integrate Newton's equations of motion using an appropriate integration scheme \todo{examples?}.
        \item Sample the values of the quantities we want to study, and add to the averages.
    \end{itemize}
    \item After all timesteps have been finished we print out the measured quantities, and we could also save the state of the system so we can continue from this state later.
\end{itemize}
%
An example of a program that implements the above procedure can be seen in \cref{list:simple_md_program}.
%
\begin{listing}[!htb]%
\begin{cppcode*}{gobble=4}
    System system = initializeSystem(parameters);
    double time = 0.0;
    double dt = 0.01;
    for (double time = 0; time < tMax; time += dt)
    {
        calculateForces(system);
        integrateEquationsOfMotion(system, dt);
        sample(system);
    }
\end{cppcode*}
\caption{%
    An example of a typical implementation of a molecular dynamics program using object-oriented programming. See \cref{list:calculate_forces,list:regular_verlet,list:sampling} for examples of implementations of the functions \texttt{calculateForces}, \texttt{integrateEquationsOfMotion}, and \texttt{sample}.%
    \label{list:simple_md_program}%
}%
\end{listing}%

When starting a new simulation we usually initialize the positions of the atoms by putting them on a regular grid like a face-centered cubic (fcc), a body-centered cubic (bcc), or a simple cubic grid. The purpose of this is to not have any atoms too close to each other, which we see from the $r^{-12}$ term would give very big forces\todo{not defined yet... move this section?}, and to start with the atoms in a state from which we are able to quickly get to the state we want to study. If we for example want to study a liquid argon system, it is wise to start in an unstable crystal state, by for example using a low density or high temperature, so that the system would melt spontaneously when we start the simulation.

\section{Calculation of forces\label{sec:program:lj}}
The forces are calculated from the derivatives of interatomic potentials, that usually only depend on the positions of the atoms. The potentials are generally of the form
\begin{align*}
    U(\rvec) = \sum_{i<j} U_{ij}(r_{ij}) + \sum_{i<j<k} U_{ijk}(\rvec_i, \rvec_i, \rvec_k) + \dots,
\end{align*}
where $\rvec_i$ is the position of atom $i$, $r_{ij}$ is the distance between atom $i$ and $j$, $U_{ij}$ is a two-particle potential depending only on the distance between two atoms, and $U_{ijk}$ is a three-particle potential that usually also depends on the angle between three atoms. Higher-order contributions are also often used\todo{ReaxFF}, but they are very demanding to evaluate numerically.

The potentials are often developed from quantum mechanical calculations, and when doing this one has to weigh the benefits of having a complex potential that models the interactions accurately, against having a less complex potential that will be easier to implement, and faster to evaluate. The limiting factor in any molecular dynamics calculation is the cost of doing simulations on high-performance computing clusters\hl{like abel}, but luckily it seems like the progress in \hl{CPU} development still seems to follow Moore's Law\hl{source?}, which states that the number of transistors on integrated circuits double approximately every two years\cite{moore1965cramming}, effectively halving the price of doing \hl{the same computation}\hl{(source?)} every two years.

In this example we will be using a potential first seen as early as 1924\cite{jones1924potential} called the Lennard-Jones potential, \hl{after its creator(s)}, who used to to study the \hl{noble gas} Argon \hl{(among other stuff?)}. The potential is a simple two-particle potential with the following form
% To model a simple mono-atomic system we use the well-known Lennard-Jones potential\cite{jones1924potential}, which when applied on the noble gas \hl{(inert)} Argon gives results that are in good agreement with experimental results. The potential is usually written as follows
\begin{align}
%     U(r) = 4\varepsilon \Big[
%     \underbrace{
%         \left(\frac{\sigma}{r}\right)^{12}
%     }_{\text{attraction}}
%      - 
%     \underbrace{
%         \left(\frac{\sigma}{r}\right)^6
%     }_{\text{repulsion}}
%     \Big],
    U(r_{ij}) = 4\varepsilon\left[ \left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^{6} \right]
    = \varepsilon\left[ \left(\frac{r_m}{r}\right)^{12} - 2\left(\frac{r_m}{r}\right)^{6} \right],
    \label{eq:lennard-jones_potential}
\end{align}
where $\sigma$ is the distance between where the potential is zero \hl{(the equilibrium distance between the atoms)}, $\varepsilon$ is related to the strength of the potential (the minimum value of the potential), and $r_m = 2^{1/6} \sigma$ is the distance where the potential is at its minimum. The $r^{-12}$-term is a repulsive term that describes \hl{Pauli repulsion/steric repulsion/overlap of electron orbitals} and the $r^{6}$-term is an attractive term that describes \hl{long range/van der Waals/dipole-dipole/dispersion} interactions. \todo{something about physical justification, use 6 for repulsive because $r^{12} = (r^6)^2$}. 

Even though the potential is simple, it describes many properties noble gases like Argon well, and has been used by many \todo{to study what? Examples}. See \cref{fig:lennard-jones_potential} for a plot of the potential using the parameters usually used for simulating Argon\cite{frenkel2001understanding}, $\sigma = 3.405$~\AA\ and $\varepsilon = 0.010318$~eV.
%
\begin{figure}[htpb]%
    \centering%
    \includesvg[width=0.7\textwidth, svgpath=./images/lennard-jones/]{lennard-jones_manualalign}%
%     \includesvg[width=0.7\textwidth, svgpath=./images/lennard-jones/]{lennard-jones}%
    \caption{%
        Plot of the Lennard-Jones potential, as stated in \cref{eq:lennard-jones_potential}. Using the parameters usually used for simulating Argon\cite{frenkel2001understanding}, $\sigma = 3.405$~\AA\ and $\varepsilon = 0.010318$~eV.%
        \label{fig:lennard-jones_potential}%
    }%
\end{figure}%

\subsection{Newton's third law}
When calculating two-particle forces like the Lennard-Jones potential\todo{only for 2-particle forces???} there is a simple optimization that lets us halve the number of computations, by utilizing Newton's third law. We see that when evaluating $U(r_{ij})$, the force will have the same magnitude if we switch particle $i$ and $j$. This means that when we have calculated the force $\vec F_{ij}$, from particle $j$ on particle $i$, we know that the force on atom $j$ from particle $i$ will have the same magnitude, and we can simply add the opposite force to atom $j$, $\vec F_{ji} = -\vec F_{ij}$. This way we only have to calculate the forces between particle $i$ and particles $j>i$ in the main force loop.

See \cref{list:calculate_forces,list:calculate_force_between_atoms} for an example of how to implement force calculation using the Lennard-Jones potential, using the optimization \hl{of} Newton's third law.
%
\begin{listing}[!htb]%
% \begin{cppcode*}{gobble=4}
%     void calculateForces(System &system)
%     {
%         for (Atom *atom1 : system.atoms())
%         {
%             for (Atom *atom2 : system.atoms())
%             {
%                 
%             }
%         }
%     }
% \end{cppcode*}
%         for (vector<Atom*>::iterator atom1 = atoms.begin(); atom1 != atoms.end(); ++atom1)
\begin{cppcode*}{gobble=4}
    void calculateForces(System &system)
    {
        const vector<Atom*> &atoms = system.atoms();
        for (auto atom1 = atoms.begin(); atom1 != atoms.end(); ++atom1)
        {
            // Use Newton's third law to skip half the force calculations
            for (auto atom2 = atom1.next(); atom2 != atoms.end(); ++atom2)
            {
                vec3 force = calculateForceBetweenTwoAtoms(*atom1, *atom2);
                
                (*atom1)->force() += force;
                (*atom2)->force() -= force; // Newton's third law
            }
        }
    }
\end{cppcode*}
\caption{%
%     An example of how to implement the velocity Verlet integration scheme using \cpp-like object-oriented programming.%
    Implementation of \texttt{calculateForces} from \cref{list:simple_md_program}.%
    \label{list:calculate_forces}%
}%
\end{listing}%
%
\begin{listing}[!htb]%
\begin{cppcode*}{gobble=4}
    vec3 calculateForceBetweenTwoAtoms(Atom *atom1, Atom *atom2)
    {
        vec3 drVec = atom1->position() - atom2->position();
        
        double dr2 = drVec.lengthSquared();
        double dr6 = dr2*dr2*dr2;

        double LJforce = 24.0*(2.0 - dr6)/(dr6*dr6*dr2);
        vec3 force = drVec*LJforce;
        
        return force;
    }
\end{cppcode*}
\caption{%
%     An example of how to implement the velocity Verlet integration scheme using \cpp-like object-oriented programming.%
    Implementation of \texttt{calculateForceBetweenTwoAtoms} from \cref{list:calculate_forces}.%
    \label{list:calculate_force_between_atoms}%
}%
\end{listing}%


\input{molecular_dynamics/integration_scheme.tex}


\section{Boundary conditions}
\todo[inline]{Cite Born and Von Karman 1912? (See Comp. Sim. of Liquids p. 24 (39)}
In theory we now have a working molecular dynamics program by combining \cref{list:simple_md_program,list:calculate_forces,list:calculate_force_between_atoms,list:regular_verlet}. But if we start our simulations we will quicly see that the particles will start spreading out into space, since we haven't implemented any kind of boundary conditions. The particles that are on the surface of our initial system will feel very different forces than the ones in the center\hl{, and, depending on the potential, will not behave as intended?}. When simulating \hl{bulk} liquids and solids we remedy this by using periodic boundary conditions. This means that we repeat the \hl{simulation box} \hl{virtually} an infinite number of times in each direction, so that all atoms \hl{have a bulk-like environment}. Atom $l$ will then have what we call an \hl{\emph{image}/``image''} in all other neighbor boxes, with position
\begin{align}
    \rvec_l^{ijk} = \rvec_l + iL_x + jL_y + kL_z,
    \label{eq:pbc_positions}
\end{align}
where $(L_x, L_y, L_z)$ is the dimensions of the box, and $(i, j, k)$ is the index of the \hl{neighbor box/periodic image box}. In reality we still have the same number of atoms, but the atoms on near the boundaries of the \hl{simulation box} will now be \hl{affected} by the atoms on the opposite side of the \hl{box}.

The first thing we have to do to implement periodic boundary conditinos is to check if any atoms have moved outside the \hl{boundaries} of the system after each time we update the position. If they have moved outside the boundaries of the system we see from \cref{eq:pbc_positions} that we can translate them back into the system by adding or subtracting \hl{system sizes} in each direction. An example of how to do this can be seen in \cref{list:pbc}.
\begin{listing}[!htb]%
% \begin{cppcode*}{gobble=4}
%     void checkBoundaryConditions(System &system, const vec3 &systemSize)
%     {
%         for (Atom *atom : system.atoms())
%         {
%             for (int dim = 0; dim < 3; dim++)
%             {
%                 if (atom->position()[dim] < 0.0) 
%                     atom->position()[dim] += systemSize[dim];
%                 else if (atom->position()[dim] >= systemSize[dim]) 
%                     atom->position()[dim] -= systemSize[dim];
%             }
%         }
%     }
% \end{cppcode*}%
\begin{cppcode*}{gobble=4}
    void checkBoundaryConditions(System &system)
    {
        for (Atom *atom : system.atoms())
        {
            for (int dim = 0; dim < 3; dim++)
            {
                if (atom->position()[dim] < 0.0) 
                    atom->position()[dim] += system.size()[dim];
                else if (atom->position()[dim] >= system.size()[dim]) 
                    atom->position()[dim] -= system.size()[dim];
            }
        }
    }
\end{cppcode*}
\caption{%
    \texttt{checkBoundaryConditions}. \hl{assumes no more than one box outside...}%
    \label{list:pbc}%
}%
\end{listing}%

A consequence of using periodic boundary conditions is that each atom is now \hl{affected} by an infinite number of atoms. To avoid having to do an infinite number of evaluations of the potential we implement something called the \hl{\emph{minimum image convention}/``minimum image convention''} \hl{source/cite?}. This \hl{means/implies} that we only calculate the force between atom $i$ and the \hl{\emph{nearest/closest}} image of each atom $j$, effectively limiting the \hl{reach} of the potential to \hl{half?} the size of the system. \todo{really $L\sqrt{3}$, diagonally} \hl{In doing this we do an approximation, but this is ok??.}

To find the distance between atom $i$ and the closest image of atom $j$ we \hl{just} have to calculate the distance between $i$ and \hl{any image of} $j$, $\rvec_{ij}$, and then check if the length of this vector is more than half the system size in any of the three dimensions. See \cref{list:minimum_image_convention} for an implementation of how to find the distance between a point $u$ to the closest image of a point $v$ using the \emph{minimum image convention}.
\begin{listing}[!htb]%
\begin{cppcode*}{gobble=4}
    double calculateDistanceSquaredUsingMinimumImageConvention(
        const vec3 &u, const vec3 &v, 
        const vec3 &systemSize, const vec3 &halfSystemSize)
    {
        vec3 dr = u - v;
        for (int dim = 0; dim < 3; dim++)
        {
            if (dr[dim] >= halfSystemSize[dim]) dr -= systemSize[dim];
            else if (dr[dim] < -halfSystemSize[dim]) dr += systemSize[dim];
        }
        return dr.lengthSquared(); // Avoid calculating $\sqrt{dr^2}$
    }
\end{cppcode*}
\caption{%
    An example of how to find the distance between two points \texttt{u} and \texttt{v} in a periodic system of size \texttt{systemSize} using the \emph{minimum image convention}. We calculate the distance squared to avoid taking the square root, since this is a slow operation \hl{on a computer}.%
    \label{list:minimum_image_convention}%
}%
\end{listing}%

% The use of periodic boundary conditions has some other consequences for our program. The first thing we need to consider is how to calculate the forces. In theory each atom is now affected by a force from an infinite number of numbers, since we have the image of particle $j$ in an infinte number of repeating periodic boxes. Calculating an infinite number of forces for all atoms in \hl{the periodic box} is unfeasible in a numerical experiment (in nature this infinite sum is incredibly evaluated every timestep $dt = 5.39106(32)\times 10^{-44} \text{s}$ (Planck time)), so we make an approximation where we only consider the force from atoms within the size of the box.

% \hl{force calculation unnecessary} Using the Lennard-Jones potential we see that the force from the potential decays as $1/r^{12}$, meaning that the force from most atoms will be neglible. \cref{fig:lennard-jones_potential}

